---
interface Heading {
  depth: number;
  slug: string;
  text: string;
}

interface Props {
  headings: Heading[];
}

const { headings } = Astro.props;

// 只显示 h2 和 h3
const tocHeadings = headings.filter(h => h.depth >= 2 && h.depth <= 3);
---

{tocHeadings.length > 0 && (
  <>
    {/* Desktop TOC - Fixed sidebar */}
    <div class="hidden xl:block toc-sidebar" data-toc-sidebar>
      <h3 class="toc-title">
        Contents
      </h3>
      <nav class="toc-nav" aria-label="文章目录">
        {tocHeadings.map(heading => (
          <a
            href={`#${heading.slug}`}
            class={`toc-link ${heading.depth === 3 ? 'toc-link-depth-3' : ''}`}
            data-heading-id={heading.slug}
            aria-current="false"
          >
            {heading.text}
          </a>
        ))}
      </nav>
    </div>

    {/* Mobile TOC - Collapsible */}
    <div class="xl:hidden mb-8">
      <details class="toc-mobile group">
        <summary class="flex items-center justify-between p-4 bg-[var(--bg-secondary)] rounded-lg cursor-pointer list-none">
          <span class="font-medium text-[var(--text-primary)]">文章目录</span>
          <svg
            class="w-5 h-5 text-[var(--text-muted)] transition-transform duration-200 group-open:rotate-180"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
          </svg>
        </summary>
        <nav class="p-4 space-y-2 border-t border-[var(--border-color)]">
          {tocHeadings.map(heading => (
            <a
              href={`#${heading.slug}`}
              class={`block text-sm transition-colors duration-200 ${
                heading.depth === 3 ? 'pl-4 text-[var(--text-muted)]' : 'text-[var(--text-secondary)]'
              } hover:text-[var(--text-primary)]`}
            >
              {heading.text}
            </a>
          ))}
        </nav>
      </details>
    </div>
  </>
)}

<style>
  /* TOC Sidebar - Sticky */
  .toc-sidebar {
    position: sticky;
    top: 80px;
  }

  /* TOC Title - Playfair Display italic */
  .toc-title {
    font-family: 'Playfair Display', serif;
    font-style: italic;
    font-size: 18px;
    color: #ffffff;
    margin-bottom: 1rem;
    padding-bottom: 0.75rem;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  }

  /* TOC Navigation */
  .toc-nav {
    display: flex;
    flex-direction: column;
  }

  /* TOC Link Styles - Desktop only */
  .toc-sidebar .toc-link {
    display: block;
    font-size: 13px;
    color: #6B7280;
    padding: 0.375rem 0;
    padding-left: 0.75rem;
    text-decoration: none;
    border-left: 2px solid transparent;
    transition: color 0.2s ease, border-left-color 0.2s ease;
    line-height: 1.5;
  }

  .toc-sidebar .toc-link-depth-3 {
    padding-left: 1.5rem;
  }

  .toc-sidebar .toc-link:hover {
    color: #ffffff;
  }

  .toc-sidebar .toc-link.active {
    color: #A855F7;
    border-left-color: #A855F7;
  }

  /* Mobile TOC Styles */
  .toc-mobile > summary::-webkit-details-marker {
    display: none;
  }
</style>

<script>
  // Highlight current heading on scroll
  let observer: IntersectionObserver | null = null;

  function initTOC() {
    // Clean up previous observer
    if (observer) {
      observer.disconnect();
      observer = null;
    }

    const tocSidebar = document.querySelector('[data-toc-sidebar]');

    // Only enable on desktop (when TOC is visible)
    if (!tocSidebar || tocSidebar.offsetParent === null) return;

    // Only select toc links within the desktop sidebar
    const tocLinks = tocSidebar.querySelectorAll('.toc-link');
    if (!tocLinks.length) return;

    // Collect all headings that have corresponding toc links
    const headings: { id: string; element: Element; link: Element }[] = [];
    tocLinks.forEach(link => {
      const href = link.getAttribute('href');
      if (!href) return;

      // Extract id from href (#xxx or full URL with #xxx)
      const hashIndex = href.lastIndexOf('#');
      if (hashIndex === -1) return;

      const id = decodeURIComponent(href.substring(hashIndex + 1));
      const heading = document.getElementById(id);
      if (heading) {
        headings.push({ id, element: heading, link });
      }
    });

    if (headings.length === 0) return;

    // Default highlight first heading
    headings[0].link.classList.add('active');
    headings[0].link.setAttribute('aria-current', 'true');

    // IntersectionObserver with optimized settings
    const observerOptions = {
      root: null,
      rootMargin: '-100px 0px -70% 0px', // Adjusted for better detection
      threshold: 0,
    };

    observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          // Remove active class from all toc links only
          tocLinks.forEach(link => {
            link.classList.remove('active');
            link.setAttribute('aria-current', 'false');
          });

          // Find corresponding link and activate it
          const match = headings.find(h => h.element === entry.target);
          if (match) {
            match.link.classList.add('active');
            match.link.setAttribute('aria-current', 'true');
          }
        }
      });
    }, observerOptions);

    headings.forEach(h => observer?.observe(h.element));

    // Smooth scroll for TOC links
    tocLinks.forEach(link => {
      link.addEventListener('click', (e) => {
        e.preventDefault();
        const targetId = link.getAttribute('href')?.slice(1);
        const target = document.getElementById(targetId || '');
        if (target) {
          const offset = 100; // Adjusted for header height
          const targetPosition = target.getBoundingClientRect().top + window.scrollY - offset;
          window.scrollTo({
            top: targetPosition,
            behavior: 'smooth',
          });
        }
      });
    });
  }

  // Initialize on page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initTOC);
  } else {
    initTOC();
  }

  // Re-initialize after Astro page transitions
  document.addEventListener('astro:page-load', initTOC);

  // Cleanup before page transitions
  document.addEventListener('astro:before-swap', () => {
    if (observer) {
      observer.disconnect();
      observer = null;
    }
  });
</script>
